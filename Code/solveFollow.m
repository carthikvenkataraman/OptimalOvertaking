function res=yalmipsolve_follow(task)
% x is state vector:  
%   x(1) = x;            [s/m] inverse longitudinal velocity of the ego vehicle
%   x(2) = vx;             [m/s] longitudinal velocity of the ego vehicle
%   x(3) = y;             [m]   lateral position of the ego vehicle

%u is control vector:
%   u(1) = u_1=F_E*z_E^3/m; [s/m^2] input 1 FEL?? u och dy ist
%   u(2) = v_Ey;            [m/s]   lateral velocity of the ego vehicle
dt = task.dt ; N=task.N; yr=task.E.yref; vL=task.L.vx; vr=task.E.vref;

% Copied from space yalmip
   
road=task.road;  vrmean=mean(vr);
slip=tan(task.E.maxslipangle); m=task.E.weight;
epsilon=task.E.vxmin+0.01; Fr=task.E.Fr;
%% Yalmip
%State varibles
x=sdpvar(N,1);
vx=sdpvar(N,1);
y=sdpvar(N,1);
%Input varibles
ax=sdpvar(N-1,1);
vy=sdpvar(N-1,1);

%Varibles for cost fcn
dax=(ax(2:end)-ax(1:end-1))/dt;        % derivative on acc in x
ay=(vy(2:end)-vy(1:end-1))/dt;           % acc in y

k=1;
solvertime=0;

%Weights
q1 = 1;
q2 = 1;
q3 = 1;
q4 = 1;
q5 = 1;
q6 = 1;

cost = (sum((vx-(vr-task.L.vx)).^2)*q1 + (sum((y-yr).^2))*q2 ...
    + sum(ax.^2)*q3 + sum(vy.^2)*q4 ...
    + sum(dax.^2)*q5 + sum(ay.^2)*q6);

% Vehicle dynamics
C1=[...
    x(2:N)==x(1:N-1) + vx(1:N-1)*dt...
    vx(2:N)==vx(1:N-1) + ax(1:N-1)*dt...
    y(2:N)==y(1:N-1)+vy(1:N-1)*dt...
    ];

    %inequality constraints
C2=[...
    x <= -task.L.longsafetymargin ...
%     vx >= 0 ...
    vx <= -x/dt ...
    %y(1:N) >= task.zone.ymin(1:N) ...
    y <= task.zone.ymax ...
    %ax >= task.E.axmin ...
    %ax <= task.E.axmax ...
    vy >= task.E.vymin ... % maybe include speed dependent
    vy <= 0 ... % To only allow right turns, otherwise: task.E.vymax ...
    x(1) == task.E.x0 - task.L.x0...
    vx(1) == task.E.vx0 - task.L.vx...
    vx(N) == 0 ...
    y(1) == task.E.y0 ...
    y(N) == task.E.yref(end) ...
    vy(1) == task.E.vy0 ...
    ];
%     
% % Vehicle dynamics
%     C1=[...
%         
%         x(2:N)==x(1:N-1) + task.L.vx*dt - vx(1:N-1)*dt...
%         vx(2:N)==vx(1:N-1)+ax(1:N-1)*dt...
%         y(2:N)==y(1:N-1)+vy(1:N-1)*dt...
%         ];
 
%inequality constraints
% C2=[...
%     %x >= 0 ...
%     x >= task.L.longsafetymargin ...
%     %vx >= 0 ...
%     vx <= (task.L.x0-task.E.x0)/dt ...
%     y >= task.zone.ymin ...
%     y <= task.zone.ymax ...
%     ax >= task.E.axmin ...
%     ax <= task.E.axmax ...
%     vy >= task.E.vymin ... % maybe include speed dependent
%     vy <= 0 ... % To only allow right turns, otherwise: task.E.vymax ...
%     x(1) == task.L.x0-task.E.x0...
%     vx(1) == task.E.vx0-task.L.vx ...
%     %vx(N) == 0 ... karthik test
%     y(1) == task.E.y0 ...
%     y(N) == task.E.yref(end) ... % ÄNDRA HÄR FÖR ATT KLARA LANE CHANGE--------------
%     vy(1) == task.E.vy0 ...
%     ];



% if task.oncomingveh && task.egofirst % Not of interest, ONCOMING
%     C3=y(task.zone.ixov) <= (task.O.y0 - road.lanewidth - road.lanewidth/task.O.lf*(task.s(task.zone.ixov)-task.O.x0 + (vL-task.O.vx)*t(task.zone.ixov)*St))/Sy;
% elseif task.oncomingveh && ~task.egofirst % Not of interest, ONCOMING
%     C3=y(task.zone.ixov) <= (task.O.y0 - road.lanewidth + road.lanewidth/task.O.lf*(task.s(task.zone.ixov)-task.O.x0 + (vL-task.O.vx)*t(task.zone.ixov)*St))/Sy;
% if task.adjacentveh && task.ego==1 % infront of first vehicle
%     C3=y(task.zone.ixov) <= (task.A.y0 - road.lanewidth + road.lanewidth/task.A.lr*(task.s(task.zone.ixov)-task.A.x0 + (vL-task.A.vx)*t(task.zone.ixov)*St))/Sy;
% elseif task.adjacentveh && task.ego==2 %Behind first veh and infront of second vehicle
%     C3=[y(task.zone.ixov) <= (task.A.y0 + road.lanewidth - road.lanewidth/task.A.lr*(task.s(task.zone.ixov)-task.A.x0 + (vL-task.A.vx)*t(task.zone.ixov)*St))/Sy...
%         y(task.zone.ixov) <= (task.A2.y0 - road.lanewidth + road.lanewidth/task.A2.lr*(task.s(task.zone.ixov)-task.A2.x0 + (vL-task.A2.vx)*t(task.zone.ixov)*St))/Sy];    
% elseif  task.adjacentveh && task.ego==3 % Behind 2:nd vehicle
%     C3=y(task.zone.ixov) <= (task.A2.y0 + road.lanewidth - road.lanewidth/task.A2.lr*(task.s(task.zone.ixov)-task.A2.x0 + (vL-task.A2.vx)*t(task.zone.ixov)*St))/Sy;    
% 
% end
    
C=[C1 C2];
options = sdpsettings('solver','QuadProg','verbose',3);
optimization=optimize(C,cost,options);

res=struct;
res.status=optimization;
res.solvertime=solvertime;
res.cost.total=value(cost);
res.yE=value(y);                                          %[m] lateral position
res.vEx=value(vx);                                        %[m/s] longitudinal speed
res.vEy=[value(vy); value(vy(N-1))];                                        %[m/s] lateral speed
res.ts=ones(N,1)*dt;                                                %[s] time samples
res.t=[0;cumsum(res.ts(1:N-1))];                                               %[s] travel time
res.xE=value(x);                                                 %[m] longitudinal position
%res.topt=value(t)*St;
res.weights=[q1 q2 q3 q4 q5 q6];
%res.z=value(z*Sz);

